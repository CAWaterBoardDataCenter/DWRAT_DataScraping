# Combine these three data frames
ewrims_flat_file_party_Final <- rbind(Phone, Nine, Email)
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Priority_Date_Postprocessing.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Priority_Date_Postprocessing.R")
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Demand_Master_Script.R")
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
26*2
26*3
26*6
26*7
j = 45
45 - 26
LETTERS[19]
c(LETTERS, LETTERS)[45]
rep(LETTERS, 2)
rep(LETTERS, 2)[45]
j = 84
i = 3
26 * (i - 1)
j >= 26 * (i - 1) && j <= 26 * i
26 * i
i =
4
j >= 26 * (i - 1) && j <= 26 * i
c("A", "B", "C", "D", "E", "F", "G")[i - 1]
LETTERS[i - 1]
rep(LETTERS, i)[j]
j
26 * (i - 1)
79
80
81
82
83
84
7 * 26
# If the procedure reaches this point, throw an error
stop(paste0("The table's column count exceeds the supported length for this function (max is 182, column count is ", j, ")"))
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
getColumnLabel(778)
getColumnLabel(121)
getColumnLabel(136)
getColumnLabel(148)
getColumnLabel(152)
getColumnLabel(156)
getColumnLabel(157)
getColumnLabel(181)
getColumnLabel(182)
getColumnLabel(183)
getColumnLabel(51)
getColumnLabel(52)
getColumnLabel(53)
getColumnLabel(27)
getColumnLabel(45)
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
getColumnLabel(45)
paste0("Module and Script Comparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted")
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
# Ask the user to specify which comparisons to run
comparisonList <- getUserChoice()
# Iterate through the user's selections
for (i in 1:length(comparisonList)) {
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
read_xlsx(col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("Module and Script Comparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
# Then, get a table (data frame) of mismatches between the two tibbles
mismatchDF <- compareCells(modXLSX, scriptXLSX)
# Save 'mismatchDF' as an Excel sheet in the directory
paste0("Module and Script Comparisons/", comparisonList[i], "/",
"Difference_Comparison_", comparisonList[i], ".xlsx") %>%
write.xlsx(x = mismatchDF, overwrite = TRUE)
# Make a note on the console about that
cat("Done!\n")
}
paste0("Module and Script Comparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted")
paste0("Module and Script Comparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE)
paste0("Module and Script Comparisons/", comparisonList[i])
paste0("Module and Script Comparisons/", comparisonList[i], "/") %>%
list.files(full.names = TRUE)
paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE)
# Iterate through the user's selections
for (i in 1:length(comparisonList)) {
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
read_xlsx(col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
# Then, get a table (data frame) of mismatches between the two tibbles
mismatchDF <- compareCells(modXLSX, scriptXLSX)
# Save 'mismatchDF' as an Excel sheet in the directory
paste0("Module and Script Comparisons/", comparisonList[i], "/",
"Difference_Comparison_", comparisonList[i], ".xlsx") %>%
write.xlsx(x = mismatchDF, overwrite = TRUE)
# Make a note on the console about that
cat("Done!\n")
}
# Import GIS data reviewed by SDU on 7/17/2023
Application_Number <- read_xlsx("InputData/RR_pod_points_MAX_MAF__20230717.xlsx")
Application_Number <- read_xlsx("InputData/RR_pod_points_MAX_MAF__20230717.xlsx")
# Change the column name from "APPL_ID" to "APPLICATION_NUMBER"
# Keep only the "APPLICATION_NUMBER" and "FREQUENCY" columns
Application_Number <- Application_Number %>%
rename(APPLICATION_NUMBER = APPL_ID) %>%
select(APPLICATION_NUMBER, FREQUENCY) %>%
unique()
sample(Application_Number$APPLICATION_NUMBER, 200)
Application_Number <- Application_Number %>%
filter(APPLICATION_NUMBER %in% sample(Application_Number$APPLICATION_NUMBER, 200))
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Demand_Master_Script.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Demand_Master_Script.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Demand_Master_Script.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Demand_Master_Script.R")
# Duplicate Report, Same Owner Module
source("Scripts/DuplicateReport_SameOwner.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("IntermediateData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# Verify that every column of 'statDF' has an owner specified (so no NA values)
stopifnot(!anyNA(statDF$Owner))
# But to simplify the process, join by more shared columns
# That way, each row of 'statDF' will have exactly one match in 'dupMonths'
# (By doing so, "one-to-one" can be specified in left_join() for an extra error check)
statDF2 <- left_join(statDF,
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
unique(),
by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
stopifnot(!anyNA(statDF$AnnualTotalStorage))
stopifnot(!anyNA(statDF$AnnualTotalDiversion))
# Select the four considered columns and use summarize() to get a count
# of the frequencies of combinations of these four columns' values
# (Note that the "1/12" has already been applied in the formula for "Duplicate_Reports_Same_Owner")
dupOwnerCounts <- statDF %>%
select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>%
group_by(YEAR, AnnualTotalDiversion, APPLICATION_NUMBER, Owner) %>%
summarize(Duplicate_Reports_Same_Owner = n() / 12, .groups = "keep")
statDF %>%
select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR)
names(statDF)
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
stopifnot(!anyNA(statDF$AnnualTotalStorage))
stopifnot(!anyNA(statDF$AnnualTotalDiversion))
names(statDF)
names(dupMonths)
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("IntermediateData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# Verify that every column of 'statDF' has an owner specified (so no NA values)
stopifnot(!anyNA(statDF$Owner))
# But to simplify the process, join by more shared columns
# That way, each row of 'statDF' will have exactly one match in 'dupMonths'
# (By doing so, "one-to-one" can be specified in left_join() for an extra error check)
statDF <- left_join(statDF,
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
unique(),
by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
stopifnot(!anyNA(statDF$AnnualTotalStorage))
stopifnot(!anyNA(statDF$AnnualTotalDiversion))
# Select the four considered columns and use summarize() to get a count
# of the frequencies of combinations of these four columns' values
# (Note that the "1/12" has already been applied in the formula for "Duplicate_Reports_Same_Owner")
dupOwnerCounts <- statDF %>%
select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>%
group_by(YEAR, AnnualTotalDiversion, APPLICATION_NUMBER, Owner) %>%
summarize(Duplicate_Reports_Same_Owner = n() / 12, .groups = "keep")
# However, "Duplicate_Reports_Same_Owner" should have a value of 0
# if "AnnualTotalDiversion" has a value of 0
# Replace values in "Duplicate_Reports_Same_Owner" accordingly to reflect that
dupOwnerCounts <- dupOwnerCounts %>%
mutate(Duplicate_Reports_Same_Owner = if_else(AnnualTotalDiversion > 0,
Duplicate_Reports_Same_Owner,
0))
# As a final step, join 'dupOwnerCounts' to 'statDF' so that the table
# gains the new column "Duplicate_Reports_Same_Owner"
# This relationship should be "many-to-one" (multiple rows in 'statDF' will
# match with the same row in 'dupOwnerCounts')
statDF <- left_join(statDF, dupOwnerCounts,
by = c("APPLICATION_NUMBER", "YEAR", "Owner", "AnnualTotalDiversion"),
relationship = "many-to-one")
# Perform one final error check
# ("Duplicate_Reports_Same_Owner" should have no missing values)
stopifnot(!anyNA(statDF$Duplicate_Reports_Same_Owner))
# Finally, write 'statDF' to an XLSX file
write.xlsx(statDF,
"OutputData/DuplicateReport_SameOwner_Scripted.xlsx",
overwrite = TRUE)
# Duplicate Report, Same Owner Module
source("Scripts/DuplicateReport_SameOwner.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Demand_Master_Script.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Demand_Master_Script.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Demand_Master_Script.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Demand_Master_Script.R")
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
# Ask the user to specify which comparisons to run
comparisonList <- getUserChoice()
# Iterate through the user's selections
for (i in 1:length(comparisonList)) {
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
read_xlsx(col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
# Then, get a table (data frame) of mismatches between the two tibbles
mismatchDF <- compareCells(modXLSX, scriptXLSX)
# Save 'mismatchDF' as an Excel sheet in the directory
paste0("Module and Script Comparisons/", comparisonList[i], "/",
"Difference_Comparison_", comparisonList[i], ".xlsx") %>%
write.xlsx(x = mismatchDF, overwrite = TRUE)
# Make a note on the console about that
cat("Done!\n")
}
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
read_xlsx(col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
scriptXLSX[204, ]
scriptXLSX[1, ]
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
read_xlsx(col_names = FALSE, col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
read_xlsx(col_names = FALSE, col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
# Then, get a table (data frame) of mismatches between the two tibbles
mismatchDF <- compareCells(modXLSX, scriptXLSX)
# Save 'mismatchDF' as an Excel sheet in the directory
paste0("Module and Script Comparisons/", comparisonList[i], "/",
"Difference_Comparison_", comparisonList[i], ".xlsx") %>%
write.xlsx(x = mismatchDF, overwrite = TRUE)
# Save 'mismatchDF' as an Excel sheet in the directory
paste0("ModuleAndScriptComparisons/", comparisonList[i], "/",
"Difference_Comparison_", comparisonList[i], ".xlsx") %>%
write.xlsx(x = mismatchDF, overwrite = TRUE)
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
read_xlsx(col_names = FALSE, col_types = "text", sheet = getSheetNum(comparisonList[i]))
list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE)
list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>% str_subset("/~\\$", negate = TRUE)
list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE)
paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE)
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE) %>%
read_xlsx(col_names = FALSE, col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE) %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
# Then, get a table (data frame) of mismatches between the two tibbles
mismatchDF <- compareCells(modXLSX, scriptXLSX)
# Save 'mismatchDF' as an Excel sheet in the directory
paste0("ModuleAndScriptComparisons/", comparisonList[i], "/",
"Difference_Comparison_", comparisonList[i], ".xlsx") %>%
write.xlsx(x = mismatchDF, overwrite = TRUE)
# Save 'mismatchDF' as an Excel sheet in the directory
paste0("ModuleAndScriptComparisons/", comparisonList[i], "/",
"Difference_Comparison_", comparisonList[i], ".xlsx") %>%
write.xlsx(x = mismatchDF, overwrite = TRUE)
# Ask the user to specify which comparisons to run
comparisonList <- getUserChoice()
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
folderName <- comparisonList
# Get a list of files in the folder
fileList <- list.files(paste0("ModuleAndScriptComparisons/", folderName))
# Verify that 'fileList' has a length of at least 3
if (length(fileList) < 3) {
stop("This module's directory has less than 3 files. It may be missing one of the required files.")
}
# First check for the presence of an XLSX file with "Scripted" in the filename
if (fileList %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted") %>%
length() == 0) {
stop("This module's directory is missing the XLSX output of its script counterpart")
}
# Then, check for the presence of a CSV file
if (fileList %>%
str_subset("\\.csv$") %>%
length() == 0) {
stop("This module's directory is missing the CSV input file used by the script and the module")
}
# Finally, check for the presence of the XLSX module file
if (!(paste0(folderName, ".xlsx") %in% fileList)) {
stop("This module's directory is missing the module XLSX file of the same name")
}
paste0(folderName, ".xlsx")
fileList
fileList %>%
str_subset("\\.xlsx$")
fileList %>%
str_subset("\\.xlsx$") %>%
str_subset("~\\$", negate = TRUE) %>%
str_subset("Scripted\\.xlsx", negate = TRUE)
fileList %>%
str_subset("\\.xlsx$") %>%
str_subset("~\\$", negate = TRUE) %>%
str_subset("Scripted\\.xlsx", negate = TRUE) %>%
length()
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
# Ask the user to specify which comparisons to run
comparisonList <- getUserChoice()
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
i - 1
i = 1
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE) %>%
read_xlsx(col_names = FALSE, col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE) %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
names(modXLSX)
names(scriptXLSX)
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE) %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
# Then, get a table (data frame) of mismatches between the two tibbles
mismatchDF <- compareCells(modXLSX, scriptXLSX)
8*26
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
# Ask the user to specify which comparisons to run
comparisonList <- getUserChoice()
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE) %>%
read_xlsx(col_names = FALSE, col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE) %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
# Ask the user to specify which comparisons to run
comparisonList <- getUserChoice()
# Notify the user which module is being checked
cat(paste0("Initiating a comparison for the '", comparisonList[i], "' module..."))
# Check the directory to verify that the required files are present
dirCheck(comparisonList[i])
# Next, read in the module and the script output file
# (Read in all columns as text strings)
modXLSX <- list.files(paste0("ModuleAndScriptComparisons/", comparisonList[i]), full.names = TRUE) %>%
str_subset("\\.xlsx$") %>% str_subset("Scripted", negate = TRUE) %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE) %>%
read_xlsx(col_names = FALSE, col_types = "text", sheet = getSheetNum(comparisonList[i]))
# The module worksheet is usually the first one,
# but there some exceptions, as specified in the if_else() statement)
scriptXLSX <- paste0("ModuleAndScriptComparisons/", comparisonList[i]) %>%
list.files(full.names = TRUE) %>% str_subset("Scripted") %>%
str_subset("/~\\$", negate = TRUE) %>% str_subset("Difference_Comparison", negate = TRUE) %>%
read_xlsx(col_types = "text", col_names = FALSE,
sheet = if_else(comparisonList[i] %in% c("Diversion_Out_Of_Season_Part_B", "QAQC_Working_File"), 2, 1))
# Verify that the dimensions match for both tibbles
dimensionCheck(modXLSX, scriptXLSX)
