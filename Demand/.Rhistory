# "DIVERSION_TYPE" is "STORAGE" only
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "STORAGE") %>%
group_by(APPLICATION_NUMBER, YEAR) %>%
summarize(AnnualTotalStorage = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR"),
relationship = "many-to-one")
# After that, calculate "AnnualTotalDiversion"
# It is simply the sum of "AnnualReportedTotalDirect" and "AnnualTotalStorage"
statFinal <- statFinal %>%
mutate(AnnualTotalDiversion = AnnualReportedTotalDirect + AnnualTotalStorage)
# Finally, only two columns remain
# They will also require a temporary DF that is joined to 'statFina'
# Start with "NumberOfOccurencesWithinSingleReport"
# Filter 'statFinal to only "DIRECT" use records
# Count the number of reports with the same "APPLICATION_NUMBER", "YEAR", and
# "TotalMonthlyDiverted" values
# (There is one important exception, however; if "TotalMonthlyDiverted" is 0,
#  the value of this new column will also be 0)
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "DIRECT") %>%
group_by(APPLICATION_NUMBER, YEAR, TotalMonthlyDiverted) %>%
summarize(NumberOfOccurencesWithinSingleReport = n(), .groups = "drop") %>%
mutate(NumberOfOccurencesWithinSingleReport =
if_else(TotalMonthlyDiverted == 0, 0L, NumberOfOccurencesWithinSingleReport))
# Join this new column to 'statFinal'
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR", "TotalMonthlyDiverted"),
relationship = "many-to-one")
# The final column "OccurencesAcrossReports" is similar
# It counts one-twelfth the number of entries with "DIRECT" usage
# that have the same "APPLICATION_NUMBER" and "AnnualTotalDiversion" values
# (And similar to before, if "AnnualTotalDiversion" is 0, this column will be 0 too)
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "DIRECT") %>%
group_by(APPLICATION_NUMBER, AnnualTotalDiversion) %>%
summarize(OccurencesAcrossReports = n(), .groups = "drop") %>%
mutate(OccurencesAcrossReports =
if_else(AnnualTotalDiversion == 0, 0, OccurencesAcrossReports / 12))
names(tempDF)
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateMonths_Years.R")
source("~/Github/DWRAT_DataScraping/Demand/ModuleAndScriptComparisons/Compare Modules and Scripts.R")
temp <- read_xlsx("InputData/ewrims_flat_file_Working_File.csv")
temp <- read.csv("InputData/ewrims_flat_file_Working_File.csv")
temp$APPLICATION_NUMBER %>% unique() %>% length()
chosenIDs <- temp$APPLICATION_NUMBER[sample(1:nrow(temp), 250)]
filteredDF <- temp %>%
filter(APPLICATION_NUMBER %in% chosenIDs)
filteredDF$WATER_RIGHT_TYPE %>% unique()
filteredDF$PRIMARY_OWNER_ENTITY_TYPE %>% unique()
read.csv("InputData/Beneficial_Use_and_Return_Flow_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Beneficial_Use_and_Return_Flow_FINAL.csv", overwrite = TRUE)
read.csv("InputData/Beneficial_Use_and_Return_Flow_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Beneficial_Use_and_Return_Flow_FINAL.csv")
read.csv("InputData/Diversion_out_of_Season_Part_A_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Diversion_out_of_Season_Part_A_FINAL.csv")
read.csv("InputData/Diversion_out_of_Season_Part_A_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Diversion_out_of_Season_Part_A_FINAL.csv")
read.csv("InputData/Diversion_out_of_Season_Part_B_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Diversion_out_of_Season_Part_B_FINAL.csv")
read.csv("InputData/ewrims_flat_file_Working_File.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/ewrims_flat_file_Working_File.csv")
read.csv("InputData/ewrims_flat_file_Working_File.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/ewrims_flat_file_Working_File.csv")
read.csv("InputData/Missing_RMS_Reports_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Missing_RMS_Reports_FINAL.csv")
read.csv("InputData/Overlapping_Water_Rights.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Overlapping_Water_Rights.csv")
read.csv("InputData/Priority_Date_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Priority_Date_FINAL.csv")
read.csv("InputData/Priority_Date_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Priority_Date_FINAL.csv")
read.csv("InputData/Statistics_FaceValue_IniDiv_Final .csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Statistics_FaceValue_IniDiv_Final .csv")
read.csv("InputData/Statistics_FaceValue_IniDiv_Final .csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Statistics_FaceValue_IniDiv_Final .csv")
read.csv("InputData/Statistics_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Statistics_FINAL.csv")
read.csv("InputData/Statistics_FINAL.csv") %>%
filter(APPLICATION_NUMBER %in% chosenIDs) %>%
write.csv("InputData/Statistics_FINAL.csv")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
filteredDF$WATER_RIGHT_TYPE %>% unique()
temp$WATER_RIGHT_TYPE %>% unique()
source("~/.active-rstudio-document")
filteredDF$WATER_RIGHT_TYPE %>% unique()
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Priority_Date.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateMonths_Years.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("InputData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# Verify that every column of 'statDF' has an owner specified (so no NA values)
stopifnot(!anyNA(statDF$Owner))
# But to simplify the process, join by more shared columns
# That way, each row of 'statDF' will have exactly one match in 'dupMonths'
# (By doing so, "one-to-one" can be specified in left_join() for an extra error check)
statDF <- left_join(statDF,
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion),
by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
stopifnot(!anyNA(statDF$AnnualTotalStorage))
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
stopifnot(!anyNA(statDF$AnnualTotalStorage))
statDF %>% filter(is.na(AnnualTotalStorage))
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateMonths_Years.R")
# Read in the input CSV file ("Statistics_FINAL.csv")
statFinal <- read.csv("InputData/Statistics_FINAL.csv")
# Create another variable that summarizes the total diversion and storage
# for each application number (separately for each month/year)
# (The only use types considered are "DIRECT" and "STORAGE")
tempDF <- statFinal %>%
filter(DIVERSION_TYPE %in% c("DIRECT", "STORAGE")) %>%
group_by(APPLICATION_NUMBER, YEAR, MONTH) %>%
summarize(TotalMonthlyDiverted = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR", "MONTH"),
relationship = "many-to-one")
# Perform similar steps for the next column, "AnnualReportedTotalDirect"
# Grouping will be done by "APPLICATION_NUMBER" and "YEAR"
# (And the "DIVERSION_TYPE" filter will be "DIRECT" only)
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "DIRECT") %>%
group_by(APPLICATION_NUMBER, YEAR) %>%
summarize(AnnualReportedTotalDirect = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR"),
relationship = "many-to-one")
# The next column is "AnnualTotalStorage"
# The steps are exactly the same as for "AnnualReportedTotalDirect" except
# "DIVERSION_TYPE" is "STORAGE" only
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "STORAGE") %>%
group_by(APPLICATION_NUMBER, YEAR) %>%
summarize(AnnualTotalStorage = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR"),
relationship = "many-to-one")
# After that, calculate "AnnualTotalDiversion"
# It is simply the sum of "AnnualReportedTotalDirect" and "AnnualTotalStorage"
statFinal <- statFinal %>%
mutate(AnnualTotalDiversion = AnnualReportedTotalDirect + AnnualTotalStorage)
# Start with "NumberOfOccurencesWithinSingleReport"
# Filter 'statFinal to only "DIRECT" use records
# Count the number of reports with the same "APPLICATION_NUMBER", "YEAR", and
# "TotalMonthlyDiverted" values
# (There is one important exception, however; if "TotalMonthlyDiverted" is 0,
#  the value of this new column will also be 0)
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "DIRECT") %>%
group_by(APPLICATION_NUMBER, YEAR, TotalMonthlyDiverted) %>%
summarize(NumberOfOccurencesWithinSingleReport = n(), .groups = "drop") %>%
mutate(NumberOfOccurencesWithinSingleReport =
if_else(TotalMonthlyDiverted == 0, 0L, NumberOfOccurencesWithinSingleReport))
# Join this new column to 'statFinal'
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR", "TotalMonthlyDiverted"),
relationship = "many-to-one")
# The final column "OccurencesAcrossReports" is similar
# It counts one-twelfth the number of entries with "DIRECT" usage
# that have the same "APPLICATION_NUMBER" and "AnnualTotalDiversion" values
# (And similar to before, if "AnnualTotalDiversion" is 0, this column will be 0 too)
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "DIRECT") %>%
group_by(APPLICATION_NUMBER, AnnualTotalDiversion) %>%
summarize(OccurencesAcrossReports = n(), .groups = "drop") %>%
mutate(OccurencesAcrossReports =
if_else(AnnualTotalDiversion == 0, 0, OccurencesAcrossReports / 12))
# Join these results to 'statFinal'
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "AnnualTotalDiversion"),
relationship = "many-to-one")
# After that, save 'statFinal' to a new XLSX file
write.xlsx(statFinal, "OutputData/DuplicateMonths_Years_Scripted.xlsx", overwrite = TRUE)
statFinal %>% filter(is.na(AnnualTotalStorage))
# Read in the input CSV file ("Statistics_FINAL.csv")
statFinal <- read.csv("InputData/Statistics_FINAL.csv")
# Add the following columns to 'statFinal'
# Column G: TotalMonthlyDiverted
# Column H: AnnualReportedTotalDirect
# Column I: AnnualTotalStorage
# Column J: AnnualTotalDiversion
# Column K: NumberOfOccurencesWithinSingleReport
# Column L: OccurencesAcrossReports
# Start with the first column "TotalMonthlyDiverted"
# Create another variable that summarizes the total diversion and storage
# for each application number (separately for each month/year)
# (The only use types considered are "DIRECT" and "STORAGE")
tempDF <- statFinal %>%
filter(DIVERSION_TYPE %in% c("DIRECT", "STORAGE")) %>%
group_by(APPLICATION_NUMBER, YEAR, MONTH) %>%
summarize(TotalMonthlyDiverted = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR", "MONTH"),
relationship = "many-to-one")
# Perform similar steps for the next column, "AnnualReportedTotalDirect"
# Grouping will be done by "APPLICATION_NUMBER" and "YEAR"
# (And the "DIVERSION_TYPE" filter will be "DIRECT" only)
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "DIRECT") %>%
group_by(APPLICATION_NUMBER, YEAR) %>%
summarize(AnnualReportedTotalDirect = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR"),
relationship = "many-to-one")
# The next column is "AnnualTotalStorage"
# The steps are exactly the same as for "AnnualReportedTotalDirect" except
# "DIVERSION_TYPE" is "STORAGE" only
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "STORAGE") %>%
group_by(APPLICATION_NUMBER, YEAR) %>%
summarize(AnnualTotalStorage = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
tempDF %>% filter(is.na(AnnualTotalStorage))
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR"),
relationship = "many-to-one")
statFinal %>% filter(is.na(AnnualTotalStorage))
names(statFinal)
# Read in the input CSV file ("Statistics_FINAL.csv")
statFinal <- read.csv("InputData/Statistics_FINAL.csv")
names(statFinal)
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Priority_Date.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateMonths_Years.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("InputData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# Verify that every column of 'statDF' has an owner specified (so no NA values)
stopifnot(!anyNA(statDF$Owner))
# But to simplify the process, join by more shared columns
# That way, each row of 'statDF' will have exactly one match in 'dupMonths'
# (By doing so, "one-to-one" can be specified in left_join() for an extra error check)
statDF <- left_join(statDF,
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion),
by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
stopifnot(!anyNA(statDF$AnnualTotalDiversion))
stopifnot(!anyNA(statDF$AnnualTotalStorage))
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
statDF %>% filter(is.na(AnnualReportedTotalDirect))
?write.csv
source("~/.active-rstudio-document")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Priority_Date.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateMonths_Years.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("InputData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
# The following columns will be added to 'statDF':
# "Owner"
# "AnnualReportedTotalDirect"
# "AnnualTotalStorage"
# "AnnualTotalDiversion"
# "Duplicate_Reports_Same_Owner"
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# NOTE
# It should be a "many-to-one" relationship,
# meaning that multiple rows of 'statDF' will match with one row of 'ownerDF'
# Verify that every column of 'statDF' has an owner specified (so no NA values)
stopifnot(!anyNA(statDF$Owner))
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using their shared columns
# In 'dupMonths', these column values should be the same for rows with the
# same "APPLICATION_NUMBER" and "YEAR" values
# But to simplify the process, join by more shared columns
# That way, each row of 'statDF' will have exactly one match in 'dupMonths'
# (By doing so, "one-to-one" can be specified in left_join() for an extra error check)
statDF <- left_join(statDF,
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion),
by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
statDF %>% filter(is.na(AnnualReportedTotalDirect))
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateMonths_Years.R")
# The main body of the script
# Read in the input CSV file ("Statistics_FINAL.csv")
statFinal <- read.csv("InputData/Statistics_FINAL.csv")
# Add the following columns to 'statFinal'
# Column G: TotalMonthlyDiverted
# Column H: AnnualReportedTotalDirect
# Column I: AnnualTotalStorage
# Column J: AnnualTotalDiversion
# Column K: NumberOfOccurencesWithinSingleReport
# Column L: OccurencesAcrossReports
# Start with the first column "TotalMonthlyDiverted"
# Create another variable that summarizes the total diversion and storage
# for each application number (separately for each month/year)
# (The only use types considered are "DIRECT" and "STORAGE")
tempDF <- statFinal %>%
filter(DIVERSION_TYPE %in% c("DIRECT", "STORAGE")) %>%
group_by(APPLICATION_NUMBER, YEAR, MONTH) %>%
summarize(TotalMonthlyDiverted = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR", "MONTH"),
relationship = "many-to-one")
# Perform similar steps for the next column, "AnnualReportedTotalDirect"
# Grouping will be done by "APPLICATION_NUMBER" and "YEAR"
# (And the "DIVERSION_TYPE" filter will be "DIRECT" only)
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "DIRECT") %>%
group_by(APPLICATION_NUMBER, YEAR) %>%
summarize(AnnualReportedTotalDirect = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR"),
relationship = "many-to-one")
# The next column is "AnnualTotalStorage"
# The steps are exactly the same as for "AnnualReportedTotalDirect" except
# "DIVERSION_TYPE" is "STORAGE" only
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "STORAGE") %>%
group_by(APPLICATION_NUMBER, YEAR) %>%
summarize(AnnualTotalStorage = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR"),
relationship = "many-to-one")
# After that, calculate "AnnualTotalDiversion"
# It is simply the sum of "AnnualReportedTotalDirect" and "AnnualTotalStorage"
statFinal <- statFinal %>%
mutate(AnnualTotalDiversion = AnnualReportedTotalDirect + AnnualTotalStorage)
# Finally, only two columns remain
# They will also require a temporary DF that is joined to 'statFina'
# Start with "NumberOfOccurencesWithinSingleReport"
# Filter 'statFinal to only "DIRECT" use records
# Count the number of reports with the same "APPLICATION_NUMBER", "YEAR", and
# "TotalMonthlyDiverted" values
# (There is one important exception, however; if "TotalMonthlyDiverted" is 0,
#  the value of this new column will also be 0)
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "DIRECT") %>%
group_by(APPLICATION_NUMBER, YEAR, TotalMonthlyDiverted) %>%
summarize(NumberOfOccurencesWithinSingleReport = n(), .groups = "drop") %>%
mutate(NumberOfOccurencesWithinSingleReport =
if_else(TotalMonthlyDiverted == 0, 0L, NumberOfOccurencesWithinSingleReport))
# Join this new column to 'statFinal'
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR", "TotalMonthlyDiverted"),
relationship = "many-to-one")
# The final column "OccurencesAcrossReports" is similar
# It counts one-twelfth the number of entries with "DIRECT" usage
# that have the same "APPLICATION_NUMBER" and "AnnualTotalDiversion" values
# (And similar to before, if "AnnualTotalDiversion" is 0, this column will be 0 too)
tempDF <- statFinal %>%
filter(DIVERSION_TYPE == "DIRECT") %>%
group_by(APPLICATION_NUMBER, AnnualTotalDiversion) %>%
summarize(OccurencesAcrossReports = n(), .groups = "drop") %>%
mutate(OccurencesAcrossReports =
if_else(AnnualTotalDiversion == 0, 0, OccurencesAcrossReports / 12))
# Join these results to 'statFinal'
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "AnnualTotalDiversion"),
relationship = "many-to-one")
# After that, save 'statFinal' to a new XLSX file
write.xlsx(statFinal, "OutputData/DuplicateMonths_Years_Scripted.xlsx", overwrite = TRUE)
statFinal %>% filter(is.na(AnnualReportedTotalDirect))
statFinal %>% filter(is.na(TotalMonthlyDiverted))
# Read in the input CSV file ("Statistics_FINAL.csv")
statFinal <- read.csv("InputData/Statistics_FINAL.csv")
# Create another variable that summarizes the total diversion and storage
# for each application number (separately for each month/year)
# (The only use types considered are "DIRECT" and "STORAGE")
tempDF <- statFinal %>%
filter(DIVERSION_TYPE %in% c("DIRECT", "STORAGE")) %>%
group_by(APPLICATION_NUMBER, YEAR, MONTH) %>%
summarize(TotalMonthlyDiverted = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
tempDF %>% filter(is.na(TotalMonthlyDiverted))
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR", "MONTH"),
relationship = "many-to-one")
statFinal %>% filter(is.na(TotalMonthlyDiverted))
tempDF %>% filter(APPLICATION_NUMBER == "A011859")
# Read in the input CSV file ("Statistics_FINAL.csv")
statFinal <- read.csv("InputData/Statistics_FINAL.csv")
# Create another variable that summarizes the total diversion and storage
# for each application number (separately for each month/year)
# (The only use types considered are "DIRECT" and "STORAGE")
tempDF <- statFinal %>%
filter(DIVERSION_TYPE %in% c("DIRECT", "STORAGE")) %>%
group_by(APPLICATION_NUMBER, YEAR, MONTH) %>%
summarize(TotalMonthlyDiverted = sum(AMOUNT, na.rm = TRUE), .groups = "drop")
# Join those results back to 'statFinal' using left_join()
# (The relationship is "many-to-one" because multiple rows in 'tempDF' will
#  use the same value from 'tempDF')
statFinal <- statFinal %>%
left_join(tempDF,
by = c("APPLICATION_NUMBER", "YEAR", "MONTH"),
relationship = "many-to-one") %>%
mutate(TotalMonthlyDiverted = replace_na(TotalMonthlyDiverted, 0))
statFinal %>% filter(is.na(TotalMonthlyDiverted))
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateMonths_Years.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Expected_Demand.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Beneficial_Use_Return_Flow.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Beneficial_Use_Return_Flow.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Beneficial_Use_Return_Flow.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Beneficial_Use_Return_Flow.R")
?any_of
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Beneficial_Use_Return_Flow.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Beneficial_Use_Return_Flow.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Beneficial_Use_Return_Flow.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Beneficial_Use_Return_Flow.R")
?across
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Beneficial_Use_Return_Flow.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Diversion_Out_Of_Season.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Missing_RMS_Reports.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/QAQC_Working_File.R")
