stopifnot(length(unique(ewrimsDF$APPLICATION_NUMBER)) == nrow(ewrimsDF))
# Next, if there are no more NA values present in the "APPLICATION_PRIMARY_OWNER" column,
if (!anyNA(ewrimsDF$APPLICATION_PRIMARY_OWNER)) {
# Simply return 'ewrimsDF'
return(ewrimsDF)
}
# Get the eWRIMS Parties flat file
# (This is an extra big file, so it may take a few minutes to load into R)
partiesDF <- "https://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file_party.csv" %>%
read_csv(col_types = cols(.default = col_character()))
# Before proceeding to the next steps,
# Restrict 'ewrimsDF' to unique combinations of "APPLICATION_NUMBER" and "APPLICATION_PRIMARY_OWNER"
# And remove rows that are NA for both columns
ewrimsDF <- ewrimsDF %>%
select(APPLICATION_NUMBER, APPLICATION_PRIMARY_OWNER) %>%
unique() %>%
filter(!(is.na(APPLICATION_NUMBER) & is.na(APPLICATION_PRIMARY_OWNER)))
# However, 'partiesDF' contains more than primary owners
# Filter down 'partiesDF' to include only "Primary Owner" (or NA) for "RELATIONSHIP_TYPE"
partiesDF <- partiesDF %>%
filter(is.na(RELATIONSHIP_TYPE) | RELATIONSHIP_TYPE == "Primary Owner")
# First, replace the NA values in those three columns with empty strings ("")
# (This will be useful when merging the name columns together)
partiesDF <- partiesDF %>%
mutate(FIRST_NAME = replace_na(FIRST_NAME, ""),
MIDDLE_NAME = replace_na(MIDDLE_NAME, ""),
LAST_NAME_OR_COMPANY_NAME = replace_na(LAST_NAME_OR_COMPANY_NAME, ""))
# Then, create a new column "MERGED_NAME"
# It will be a combination of these three columns (using paste(), with sep = " ")
# Also, remove excess spaces that may appear in the name (due to the empty string values)
partiesDF <- partiesDF %>%
mutate(MERGED_NAME = paste(FIRST_NAME, MIDDLE_NAME, LAST_NAME_OR_COMPANY_NAME) %>%
str_remove_all("^\\s+") %>% str_remove_all("\\s{2,}"))
# Extract the "APPLICATION_NUMBER" and "MERGED_NAME" columns from 'partiesDF'
# Filter its values to only applications with NA owner names in 'ewrimsDF'
partiesDF <- partiesDF %>%
filter(APPLICATION_NUMBER %in% ewrimsDF$APPLICATION_NUMBER[is.na(ewrimsDF$APPLICATION_PRIMARY_OWNER)]) %>%
select(APPLICATION_NUMBER, MERGED_NAME) %>%
unique()
stopifnot(length(unique(partiesDF$APPLICATION_NUMBER)) == nrow(partiesDF))
# Then, join 'ewrimsDF' and 'partiesDF' together
ewrimsDF %>%
left_join(partiesDF, by = "APPLICATION_NUMBER")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("InputData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
ownerDF
# Download an eWRIMS flat file (VPN required)
ewrimsDF <- "https://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file.csv" %>%
read_csv(col_types = cols(.default = col_character()))
names(ewrimsDF)
ewrimsDF %>% select(APPL_ID)
# First try to use the "PRIMARY_OWNER_NAME" column to fill in missing values
ewrimsDF <- ewrimsDF %>%
mutate(APPLICATION_PRIMARY_OWNER = if_else(is.na(APPLICATION_PRIMARY_OWNER),
PRIMARY_OWNER_NAME,
APPLICATION_PRIMARY_OWNER))
# Before proceeding to the next steps,
# Restrict 'ewrimsDF' to unique combinations of "APPL_ID" and "APPLICATION_PRIMARY_OWNER"
# And remove rows that are NA for both columns
ewrimsDF <- ewrimsDF %>%
select(APPL_ID, APPLICATION_PRIMARY_OWNER) %>%
unique() %>%
filter(!(is.na(APPL_ID) & is.na(APPLICATION_PRIMARY_OWNER)))
# Also, confirm that each "APPL_ID" only appears once in 'ewrimsDF'
stopifnot(length(unique(ewrimsDF$APPL_ID)) == nrow(ewrimsDF))
ewrimsDF$APPL_ID %>% length()
ewrimsDF$APPL_ID %>% unique() %>% length()
table(ewrimsDF$APPL_ID)
table(ewrimsDF$APPL_ID)[table(ewrimsDF$APPL_ID) > 1]
)
nrow(ewrimsDF)
length(unique(ewrimsDF$APPL_ID))
table(ewrimsDF$APPL_ID)[table(ewrimsDF$APPL_ID) > 1]
ewrimsDF %>% filter(APPL_ID == "G333079")
statDF %>% head()
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("InputData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
names(statD)
names(statDF)
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER")
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
anyNA(statDF$Owner)
statDF$Owner[is.na(statDF$Owner)]
sum(statDF$Owner == "NA")
# Verify that every column of 'statDF' has an owner specified
stopifnot(!anyNA(statDF$Owner))
dupMonths %>% head()
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using "APPLICATION_NUMBER" and "YEAR"
dupMonths %>%
select(APPLICATION_NUMBER, YEAR,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, by = c("APPLICATION_NUMBER", "YEAR"), relationship = "many-to-one")
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using "APPLICATION_NUMBER" and "YEAR"
dupMonths %>%
select(APPLICATION_NUMBER, YEAR,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, by = c("APPLICATION_NUMBER", "YEAR"), relationship = "one-to-many")
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using "APPLICATION_NUMBER" and "YEAR"
dupMonths %>%
select(APPLICATION_NUMBER, YEAR,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, ., by = c("APPLICATION_NUMBER", "YEAR"), relationship = "one-to-many")
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using "APPLICATION_NUMBER" and "YEAR"
dupMonths %>%
select(APPLICATION_NUMBER, YEAR,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, ., by = c("APPLICATION_NUMBER", "YEAR"), relationship = "many-to-one")
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using "APPLICATION_NUMBER" and "YEAR"
dupMonths %>%
select(APPLICATION_NUMBER, YEAR,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, by = c("APPLICATION_NUMBER", "YEAR"), relationship = "many-to-one")
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using "APPLICATION_NUMBER" and "YEAR"
dupMonths %>%
select(APPLICATION_NUMBER, YEAR,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, by = c("APPLICATION_NUMBER", "YEAR"), relationship = "one-to-many")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("InputData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "one-to-many") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# Verify that every column of 'statDF' has an owner specified (so no NA values)
stopifnot(!anyNA(statDF$Owner))
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using "APPLICATION_NUMBER" and "YEAR"
dupMonths %>%
select(APPLICATION_NUMBER, YEAR,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, by = c("APPLICATION_NUMBER", "YEAR"), relationship = "one-to-many")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("InputData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
# The following columns will be added to 'statDF':
# "Owner"
# "AnnualReportedTotalDirect"
# "AnnualTotalStorage"
# "AnnualTotalDiversion"
# "Duplicate_Reports_Same_Owner"
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# NOTE
# It should be a "many-to-one" relationship,
# meaning that multiple rows of 'statDF' will match with one row of 'ownerDF'
# Verify that every column of 'statDF' has an owner specified (so no NA values)
stopifnot(!anyNA(statDF$Owner))
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using "APPLICATION_NUMBER" and "YEAR"
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, by = c("APPLICATION_NUMBER", "YEAR", "MONTH"), relationship = "one-to-one")
dupMonths[1, ]
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using "APPLICATION_NUMBER" and "YEAR"
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
# In 'dupMonths', these column values should be the same for rows with the
# same "APPLICATION_NUMBER" and "YEAR" values
# But to simplify the process, join by all shared columns
statDF <- dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion) %>%
right_join(statDF, by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
statDF
dupMonths %>% head()
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion)
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# The main body of the script
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("InputData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
# The following columns will be added to 'statDF':
# "Owner"
# "AnnualReportedTotalDirect"
# "AnnualTotalStorage"
# "AnnualTotalDiversion"
# "Duplicate_Reports_Same_Owner"
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# NOTE
# It should be a "many-to-one" relationship,
# meaning that multiple rows of 'statDF' will match with one row of 'ownerDF'
# Verify that every column of 'statDF' has an owner specified (so no NA values)
stopifnot(!anyNA(statDF$Owner))
left_join(statDF,
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion),
by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
# In 'dupMonths', these column values should be the same for rows with the
# same "APPLICATION_NUMBER" and "YEAR" values
# But to simplify the process, join by all shared columns
statDF <- left_join(statDF,
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion),
by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
stopifnot(!anyNA(statDF$AnnualTotalStorage))
stopifnot(!anyNA(statDF$AnnualTotalDiversion))
# Calculate the final column next ("Duplicate_Reports_Same_Owner")
# This column involves checking "AnnualTotalDiversion"
# If that column has a value of 0, this column is also 0
# Otherwise, this column is one-twelfth of the counts of
unique(statDF) %>% nrow()
# Calculate the final column next ("Duplicate_Reports_Same_Owner")
# This column involves checking "AnnualTotalDiversion"
# If that column has a value of 0, this column is also 0
# Otherwise, this column is one-twelfth of the counts of
nrow(unique(statDF))
nrow(statDF)
head(statDF)
statDF %>% select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% group_by(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, Year) %>% summarize(COUNTS = n())
statDF %>% select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% group_by(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% summarize(COUNTS = n())
statDF %>% select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% group_by(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% summarize(COUNTS = n() / 12)
temp <- statDF %>% select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% group_by(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% summarize(COUNTS = n() / 12)
?group_by
temp <- statDF %>% select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR, MONTH) %>% group_by(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% summarize(COUNTS = n() / 12)
temp <- statDF %>% select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% group_by(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% summarize(COUNTS = n() / 12)
temp
statDF %>% filter(APPLICATION_NUMBER == "A001205" & Owner == "Jackson Family Wines, Inc." & YEAR == 2014)
statDF %>% filter(APPLICATION_NUMBER == "A001205" & Owner == "Jackson Family Wines, Inc." & YEAR == 2014 & AnnualTotalDiversion == 0)
statDF %>% filter(APPLICATION_NUMBER == "A001205" & Owner == "Jackson Family Wines, Inc." & YEAR == 2014 & AnnualTotalDiversion == 0) %>% nrow()
temp <- statDF %>% select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% group_by(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% summarize(COUNTS = n() / 12)
temp <- statDF %>% select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% group_by(YEAR, AnnualTotalDiversion, APPLICATION_NUMBER, Owner) %>% summarize(COUNTS = n() / 12)
?summarize
temp <- statDF %>% select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>% group_by(YEAR, AnnualTotalDiversion, APPLICATION_NUMBER, Owner) %>% summarize(COUNTS = n() / 12, .groups = "keep")
temp
# Calculate the final column next ("Duplicate_Reports_Same_Owner")
# This column involves checking "AnnualTotalDiversion"
# If that column has a value of 0, this column is also 0
# Otherwise, this column is one-twelfth of the counts of rows with this row's
# values for "AnnualTotalDiversion", "APPLICATION_NUMBER", "Owner", and "YEAR"
statDF %>%
mutate(Duplicate_Reports_Same_Owner = if_else(AnnualTotalDiversion > 0,
temp$COUNTS[temp$AnnualTotalDiversion == AnnualTotalDiversion & temp$YEAR == YEAR & temp$APPLICATION_NUMBER == APPLICATION_NUMBER & temp$Owner == Owner],
0))
temp$COUNTS[c(1, 2, 3, 4, 2)]
which(temp$AnnualTotalDiversion == AnnualTotalDiversion & temp$YEAR == YEAR & temp$APPLICATION_NUMBER == APPLICATION_NUMBER & temp$Owner == Owner)
which(temp$AnnualTotalDiversion == statDF$AnnualTotalDiversion & temp$YEAR == statDF$YEAR & temp$APPLICATION_NUMBER == statDF$APPLICATION_NUMBER & temp$Owner == statDF$Owner)
temp$AnnualTotalDiversion == statDF$AnnualTotalDiversion & temp$YEAR == statDF$YEAR & temp$APPLICATION_NUMBER == statDF$APPLICATION_NUMBER & temp$Owner == statDF$Owner
temp$COUNTS[temp$AnnualTotalDiversion == statDF$AnnualTotalDiversion & temp$YEAR == statDF$YEAR & temp$APPLICATION_NUMBER == statDF$APPLICATION_NUMBER & temp$Owner == statDF$Owner]
temp$COUNTS[c(1, 2, 3, 4, 2)]
anyNA(statDF$AnnualTotalDiversion)
# Select the four considered columns and use summarize() to get a count
# of the frequencies of combinations of these four columns' values
# (Note that the "1/12" has already been applied in the formula for "Duplicate_Reports_Same_Owner")
dupOwnerCounts <- statDF %>%
select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>%
group_by(YEAR, AnnualTotalDiversion, APPLICATION_NUMBER, Owner) %>%
summarize(Duplicate_Reports_Same_Owner = n() / 12, .groups = "keep")
dupOwnerCounts$Duplicate_Reports_Same_Owner
# However, "Duplicate_Reports_Same_Owner" will have a value of 0
# if "AnnualTotalDiversion" has a value of 0
# Adjust the values in "AnnualTotalDiversion" to reflect that
dupOwnerCounts %>%
mutate(Duplicate_Reports_Same_Owner = if_else(AnnualTotalDiversion > 0,
Duplicate_Reports_Same_Owner,
0))
# Select the four considered columns and use summarize() to get a count
# of the frequencies of combinations of these four columns' values
# (Note that the "1/12" has already been applied in the formula for "Duplicate_Reports_Same_Owner")
dupOwnerCounts <- statDF %>%
select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>%
group_by(YEAR, AnnualTotalDiversion, APPLICATION_NUMBER, Owner) %>%
summarize(Duplicate_Reports_Same_Owner = n() / 12, .groups = "keep")
# However, "Duplicate_Reports_Same_Owner" will have a value of 0
# if "AnnualTotalDiversion" has a value of 0
# Replace values in "AnnualTotalDiversion" accordingly to reflect that
dupOwnerCounts <- dupOwnerCounts %>%
mutate(Duplicate_Reports_Same_Owner = if_else(AnnualTotalDiversion > 0,
Duplicate_Reports_Same_Owner,
0))
# As a final step, join 'dupOwnerCounts' to 'statDF' so that the table
# gains the new column "Duplicate_Reports_Same_Owner"
left_join(statDF,
dupOwnerCounts,
by = c("APPLICATION_NUMBER", "YEAR", "Owner", "AnnualTotalDiversion"),
relationship = "many-to-one")
# As a final step, join 'dupOwnerCounts' to 'statDF' so that the table
# gains the new column "Duplicate_Reports_Same_Owner"
# This relationship should be "many-to-one" (multiple rows in 'statDF' will
# match with the same row in 'dupOwnerCounts')
statDF <- left_join(statDF, dupOwnerCounts,
by = c("APPLICATION_NUMBER", "YEAR", "Owner", "AnnualTotalDiversion"),
relationship = "many-to-one")
# Perform one final error check
# ("Duplicate_Reports_Same_Owner" should have no missing values)
stopifnot(!anyNA(statDF$Duplicate_Reports_Same_Owner))
source("~/Github/DWRAT_DataScraping/Demand/Scripts/DuplicateReport_SameOwner.R")
# The main body of the script
# Begin the procedure by collecting updated application and owner information
# This data will be downloaded from an eWRIMS Flat File
ownerDF <- getEWRIMS()
# Then, read in the input file for this module ("Statistics_FINAL.csv")
statDF <- read.csv("InputData/Statistics_FINAL.csv")
# Also, use the output of "DuplicateMonths_Years.R" ("DuplicateMonths_Years_Scripted.xlsx")
# Some of the columns are shared between these two sheets
dupMonths <- read_xlsx("OutputData/DuplicateMonths_Years_Scripted.xlsx")
# The following columns will be added to 'statDF':
# "Owner"
# "AnnualReportedTotalDirect"
# "AnnualTotalStorage"
# "AnnualTotalDiversion"
# "Duplicate_Reports_Same_Owner"
# First, create "Owner"
# Joining 'ownerDF' to 'statDF' will create this column
# (Then "APPLICATION_PRIMARY_OWNER" can be renamed to "Owner")
statDF <- statDF %>% left_join(ownerDF, by = "APPLICATION_NUMBER", relationship = "many-to-one") %>%
rename(Owner = APPLICATION_PRIMARY_OWNER)
# NOTE
# It should be a "many-to-one" relationship,
# meaning that multiple rows of 'statDF' will match with one row of 'ownerDF'
# Verify that every column of 'statDF' has an owner specified (so no NA values)
stopifnot(!anyNA(statDF$Owner))
# The next three columns ("AnnualReportedTotalDirect", "AnnualTotalStorage",
# and "AnnualTotalDiversion") were calculated in 'dupMonths'
# Join these columns to 'statDF' using their shared columns
# In 'dupMonths', these column values should be the same for rows with the
# same "APPLICATION_NUMBER" and "YEAR" values
# But to simplify the process, join by more shared columns
# That way, each row of 'statDF' will have exactly one match in 'dupMonths'
# (By doing so, "one-to-one" can be specified in left_join() for an extra error check)
statDF <- left_join(statDF,
dupMonths %>%
select(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE,
AnnualReportedTotalDirect, AnnualTotalStorage, AnnualTotalDiversion),
by = c("APPLICATION_NUMBER", "YEAR", "MONTH", "DIVERSION_TYPE"), relationship = "one-to-one")
# Ensure that the new columns have been completely filled
stopifnot(!anyNA(statDF$AnnualReportedTotalDirect))
stopifnot(!anyNA(statDF$AnnualTotalStorage))
stopifnot(!anyNA(statDF$AnnualTotalDiversion))
# Calculate the final column next ("Duplicate_Reports_Same_Owner")
# This column involves checking "AnnualTotalDiversion"
# If that column has a value of 0, this column is also 0
# Otherwise, this column is one-twelfth of the counts of rows with this row's
# values for "AnnualTotalDiversion", "APPLICATION_NUMBER", "Owner", and "YEAR"
# Because multiple rows will have the same calculation and result,
# create a separate variable to perform this counting quickly
# Select the four considered columns and use summarize() to get a count
# of the frequencies of combinations of these four columns' values
# (Note that the "1/12" has already been applied in the formula for "Duplicate_Reports_Same_Owner")
dupOwnerCounts <- statDF %>%
select(AnnualTotalDiversion, APPLICATION_NUMBER, Owner, YEAR) %>%
group_by(YEAR, AnnualTotalDiversion, APPLICATION_NUMBER, Owner) %>%
summarize(Duplicate_Reports_Same_Owner = n() / 12, .groups = "keep")
# However, "Duplicate_Reports_Same_Owner" should have a value of 0
# if "AnnualTotalDiversion" has a value of 0
# Replace values in "Duplicate_Reports_Same_Owner" accordingly to reflect that
dupOwnerCounts <- dupOwnerCounts %>%
mutate(Duplicate_Reports_Same_Owner = if_else(AnnualTotalDiversion > 0,
Duplicate_Reports_Same_Owner,
0))
# As a final step, join 'dupOwnerCounts' to 'statDF' so that the table
# gains the new column "Duplicate_Reports_Same_Owner"
# This relationship should be "many-to-one" (multiple rows in 'statDF' will
# match with the same row in 'dupOwnerCounts')
statDF <- left_join(statDF, dupOwnerCounts,
by = c("APPLICATION_NUMBER", "YEAR", "Owner", "AnnualTotalDiversion"),
relationship = "many-to-one")
# Perform one final error check
# ("Duplicate_Reports_Same_Owner" should have no missing values)
stopifnot(!anyNA(statDF$Duplicate_Reports_Same_Owner))
# Finally, write 'statDF' to an XLSX file
write.xlsx(statDF,
"OutputData/DuplicateReport_SameOwner_Scripted.xlsx",
overwrite = TRUE)
# Load in the two required input files for this module
statDF <- read.csv("InputData/Statistics_FINAL.csv")
fvDF <- read.csv("InputData/Statistics_FaceValue_IniDiv_Final .csv")
statDF %>% head()
# Create and append two new columns to 'statDF'
# "COMPOSITE_MONTHLY" and "COMPOSITE_ANNUAL"
# These columns are simply concatenations of columns in 'statDF'
statDF %>%
mutate(COMPOSITE_MONTHLY = paste0(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE),
COMPOSITE_ANNUAL = paste0(APPLICATION_NUMBER, MONTH, DIVERSION_TYPE))
# Define a vector of unique application numbers stored in 'statDF'
uniqAppNum <- unique(statDF$APPLICATION_NUMBER)
min(statDF$YEAR)
# Note the minimum and maximum years in 'statDF'
# (The minimum year should not be below 2014 for this module)
minYear <- max(2014, min(statDF$YEAR))
maxYear <- max(statDF$YEAR)
source("~/Github/DWRAT_DataScraping/Demand/Scripts/Expected_Demand.R")
# Load in the two required input files for this module
statDF <- read.csv("InputData/Statistics_FINAL.csv")
fvDF <- read.csv("InputData/Statistics_FaceValue_IniDiv_Final .csv")
# Create and append two new columns to 'statDF'
# "COMPOSITE_MONTHLY" and "COMPOSITE_ANNUAL"
# These columns are simply concatenations of columns in 'statDF'
statDF <- statDF %>%
mutate(COMPOSITE_MONTHLY = paste0(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE),
COMPOSITE_ANNUAL = paste0(APPLICATION_NUMBER, MONTH, DIVERSION_TYPE))
# Some columns in the module are important but
# not fitting as an addition to a DF (at this point)
# Save them as separate variables instead
# Define a vector of unique application numbers stored in 'statDF'
uniqAppNum <- unique(statDF$APPLICATION_NUMBER)
# Note the minimum and maximum years in 'statDF'
# (The minimum year should not be below 2014 for this module)
minYear <- max(2014, min(statDF$YEAR))
maxYear <- max(statDF$YEAR)
rep(c(1, 2), 2)
statDF %>% names()
statDF %>%
filter(MONTH == 1 & DIVERSION_TYPE == "DIRECT") %>%
select(APPLICATION_NUMBER, YEAR, )
statDF %>%
filter(MONTH == 1 & DIVERSION_TYPE == "DIRECT") %>%
select(APPLICATION_NUMBER, YEAR)
statDF %>%
filter(MONTH == 1 & DIVERSION_TYPE == "DIRECT") %>%
select(APPLICATION_NUMBER, YEAR, AMOUNT)
statDF %>%
filter(MONTH == 1 & DIVERSION_TYPE == "DIRECT") %>%
select(APPLICATION_NUMBER, YEAR, AMOUNT) %>%
group_by(APPLICATION_NUMBER, YEAR) %>%
summarize(JAN_DIRECT_DIVERSION = sum(AMOUNT))
statDF %>%
filter(MONTH == 1 & DIVERSION_TYPE == "DIRECT") %>%
select(APPLICATION_NUMBER, YEAR, AMOUNT) %>%
group_by(APPLICATION_NUMBER, YEAR) %>%
summarize(JAN_DIRECT_DIVERSION = sum(AMOUNT), .groups = "keep")
statDF$DIVERSION_TYPE %>% unique()
statDF %>% filter(DIVERSION_TYPE == "Combined (Direct + Storage)")
statDF %>% filter(APPLICATION_NUMBER == "A013062")
statDF %>% filter(APPLICATION_NUMBER == "A013062") %>% filter(YEAR == 2014)
statDF %>% filter(APPLICATION_NUMBER == "A013062") %>% filter(YEAR == 2014) %>% filter(MONTH == 3)
statDF %>%
group_by(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE) %>%
summarize(VOLUME = sum(AMOUNT), .groups = "keep")
statDF$DIVERSION_TYPE %>% unique()
statDF %>% filter(DIVERSION_TYPE == "Combined (Direct + Storage)")
statDF %>%
group_by(APPLICATION_NUMBER, YEAR, MONTH, DIVERSION_TYPE) %>%
summarize(VOLUME = sum(AMOUNT), .groups = "keep")
