Flat_File_eWRIMS <- Flat_File_eWRIMS %>%
mutate(MERIDIAN = case_when(
MERIDIAN == " San Bernardino" ~"S",
MERIDIAN == "Mount Diablo" ~"M",
MERIDIAN == "Humboldt" ~"H",
TRUE ~ MERIDIAN
))
#Add the FFMTRS field----
#This field serves as the Flat File Mountain Township Range Section field
#This field concatenates the Meridian, Township Number, Township Direction, Range Number, Range Direction, and Section Number fields
#This field is used as a basis of comparison with the MTRS field in the PLSS_Sections_Fill shapefile
Flat_File_eWRIMS$FFMTRS = paste0(Flat_File_eWRIMS$MERIDIAN, Flat_File_eWRIMS$TOWNSHIP_NUMBER,
Flat_File_eWRIMS$TOWNSHIP_DIRECTION, Flat_File_eWRIMS$RANGE_NUMBER, Flat_File_eWRIMS$RANGE_DIRECTION,
Flat_File_eWRIMS$SECTION_NUMBER)
#Convert Coordinate Fields From Character Format to Numeric Format----
Flat_File_eWRIMS <- Flat_File_eWRIMS %>%
mutate_at(.vars = vars(LATITUDE, LONGITUDE), .funs = as.numeric)
#######################################USE THIS FILE FOR THE GIS STEP##########################################################################################################################################################################
####Check your output file
write.csv(Flat_File_eWRIMS,"OutputData\\Flat_File_eWRIMS_2023-06-16.csv", row.names = FALSE)
source("~/Github/DWRAT_DataScraping/Demand/Scripts/GIS_POD_Flat_File_Prep.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/GIS_POD_Flat_File_Prep.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/GIS_POD_Flat_File_Prep.R")
source("~/Github/DWRAT_DataScraping/Demand/Scripts/GIS_POD_Flat_File_Prep.R")
# Priority Date Pre-Processing
source("Demand/Scripts/Priority_Date_Preprocessing.R")
here()
library(here)
library(here)
source("Demand/Scripts/Priority_Date_Preprocessing.R")
# Priority Date Pre-Processing
source("Scripts/Priority_Date_Preprocessing.R")
source("Scripts/GIS_POD_Flat_File_Prep.R")
library(tidyverse)
# Download in advance all flat files that will be used in the procedures of this script and the other demand-related scripts
# They will be collected from *Internal URLs* that are updated daily; a Cal EPA network connection or VPN connection is required for this step
# Save the POD flat file
download.file("http://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file_pod.csv",
"RawData/ewrims_flat_file_pod.csv", mode = "wb", quiet = TRUE)
library(tidyverse)
library(tidyverse)
# Download in advance all flat files that will be used in the procedures of this script and the other demand-related scripts
# They will be collected from *Internal URLs* that are updated daily; a Cal EPA network connection or VPN connection is required for this step
# Save the POD flat file
download.file("http://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file_pod.csv",
"RawData/ewrims_flat_file_pod.csv", mode = "wb", quiet = TRUE)
git add .
download.file("http://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file_pod.csv",
"RawData/ewrims_flat_file_pod.csv", mode = "wb", quiet = TRUE)
library(tidyverse)
# Download in advance all flat files that will be used in the procedures of this script and the other demand-related scripts
# They will be collected from *Internal URLs* that are updated daily; a Cal EPA network connection or VPN connection is required for this step
# Save the POD flat file
download.file("http://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file_pod.csv",
"RawData/ewrims_flat_file_pod.csv", mode = "wb", quiet = TRUE)
# Run the scripts one chunk at a time to insure that everything is working correctly.
#Install if you do not have in your current packages or are not up to date.----
#install.packages("tidyverse")
#install.packages("dplyr")
#Load Packages- This step must be done each time the project is opened. ----
library(tidyverse)
# Download in advance all flat files that will be used in the procedures of this script and the other demand-related scripts
# They will be collected from *Internal URLs* that are updated daily; a Cal EPA network connection or VPN connection is required for this step
# Save the POD flat file
download.file("http://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file_pod.csv",
"RawData/ewrims_flat_file_pod.csv", mode = "wb", quiet = TRUE)
# Get the master flat file as well
download.file("http://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file.csv",
"RawData/ewrims_flat_file.csv", mode = "wb", quiet = TRUE)
# Download the Water Rights Annual Water Use Report file next
# read_csv() and write_csv() are used instead of download.file() because the file is very big (more than 370 MB)
# download.file() will fail if the required download time is greater than 60 seconds
read_csv("http://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=water_use_report.csv", show_col_types = FALSE) %>%
write_csv("RawData/water_use_report.csv")
# Save the Water Rights Uses and Seasons flat file as well
read_csv("http://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file_use_season.csv", show_col_types = FALSE, col_types = cols(.default = col_character())) %>%
write_csv("RawData/ewrims_flat_file_use_season.csv")
# Get the Water Rights Parties flat file after that
# (It is also a big file that would work better with read_csv() instead of download.file())
read_csv("http://intapps.waterboards.ca.gov/downloadFile/faces/flatFilesEwrims.xhtml?fileName=ewrims_flat_file_party.csv", show_col_types = FALSE, col_types = cols(.default = col_character())) %>%
write_csv("RawData/ewrims_flat_file_party.csv")
# Read the POD flat file
Flat_File_PODs <- read.csv("RawData/ewrims_flat_file_pod.csv")
#Apply the proper filters----
##Filter for Active PODs----
Flat_File_PODs_Status <- Flat_File_PODs[Flat_File_PODs$POD_STATUS == "Active", ]
##Get unique water right types----
# WR_Types <- Flat_File_PODs$WATER_RIGHT_TYPE %>%
#   unique() %>% #extracts unique values
#   trimws() %>% #removes leading and lagging spaces
#   sort() %>%  #sorts alphabetically
#   data.frame() %>% #converts the dataset into a dataframe
#   colnames = c("WR_Types") #Assigns the column name "WR_Types"
# WR_Types #print values
#Water Right Types we ignore:
# Adjudicated
# Appropriative (State Filing)
# Cert of Right - Power
# Groundwater Recordation
# Non Jurisdictional
# Not Determined
# Section 12 File
# Temporary Permit
# Waste Water Change
##Filter by Water Right Type----
Flat_File_PODs_WR_Type <- Flat_File_PODs_Status[Flat_File_PODs_Status$WATER_RIGHT_TYPE == "Appropriative" |
Flat_File_PODs_Status$WATER_RIGHT_TYPE == "Federal Claims" |
Flat_File_PODs_Status$WATER_RIGHT_TYPE == "Federal Stockponds" |
Flat_File_PODs_Status$WATER_RIGHT_TYPE == "Registration Cannabis" |
Flat_File_PODs_Status$WATER_RIGHT_TYPE == "Registration Domestic" |
Flat_File_PODs_Status$WATER_RIGHT_TYPE == "Registration Irrigation" |
Flat_File_PODs_Status$WATER_RIGHT_TYPE == "Registration Livestock" |
Flat_File_PODs_Status$WATER_RIGHT_TYPE == "Statement of Div and Use" |
Flat_File_PODs_Status$WATER_RIGHT_TYPE == "Stockpond" |
Flat_File_PODs_Status$WATER_RIGHT_TYPE == "",]
##Get List of Water Right Statuses----
# WR_Statuses <- Flat_File_PODs$WATER_RIGHT_STATUS %>%
#   unique() %>% #Extracts unique values
#   trimws() %>% #Removes leading and lagging spaces
#   sort() %>%  #sorts alphabetically
#   data.frame() %>% #converts the dataset into a dataframe
#   colnames = c("WR_Statuses") #Assigns the column name "WR_Statuses"
#WR_Statuses #print values
##Filter by Water Right Status----
Flat_File_eWRIMS<- Flat_File_PODs_WR_Type[Flat_File_PODs_WR_Type$WATER_RIGHT_STATUS == "Active" |
Flat_File_PODs_WR_Type$WATER_RIGHT_STATUS == "Claimed - Local Oversight"|
Flat_File_PODs_WR_Type$WATER_RIGHT_STATUS == "Certified" |
Flat_File_PODs_WR_Type$WATER_RIGHT_STATUS == "Claimed"|
Flat_File_PODs_WR_Type$WATER_RIGHT_STATUS == "Completed"|
Flat_File_PODs_WR_Type$WATER_RIGHT_STATUS == "Licensed"|
Flat_File_PODs_WR_Type$WATER_RIGHT_STATUS == "Permitted"|
Flat_File_PODs_WR_Type$WATER_RIGHT_STATUS == "Registered"|
Flat_File_PODs_WR_Type$WATER_RIGHT_STATUS == "" , ]
##Remove unnecessary columns from Flat File----
#GIS pre-processing steps require you to keep only these 43 columns:
cols_to_keep <- c("APPL_ID", "APPLICATION_NUMBER", "CERTIFICATE_ID", "COUNTY", "EAST_COORD", "HUC_12_NAME", "HUC_12_NUMBER",
"HUC_8_NAME", "HUC_8_NUMBER", "LATITUDE", "LICENSE_ID", "LOCATION_METHOD", "LONGITUDE", "MERIDIAN", "NORTH_COORD",
"OBJECTID", "PARCEL_NUMBER", "PERMIT_ID", "POD_COUNT", "POD_ID", "POD_LAST_UPDATE_DATE", "POD_NUMBER",
"POD_NUMBER_GIS", "POD_STATUS", "POD_TYPE", "QUAD_MAP_NAME", "QUAD_MAP_NUMBER", "QUARTER", "QUARTER_QUARTER",
"RANGE_DIRECTION", "RANGE_NUMBER", "SECTION_CLASSIFIER", "SECTION_NUMBER", "SOURCE_NAME", "SP_ZONE",
"SPECIAL_USE_AREA", "TOWNSHIP_DIRECTION", "TOWNSHIP_NUMBER", "TRIB_DESC", "WATER_RIGHT_STATUS",
"WATER_RIGHT_TYPE", "WATERSHED", "WR_WATER_RIGHT_ID")
Flat_File_eWRIMS <- Flat_File_eWRIMS[, cols_to_keep, drop = FALSE]
#Replace Meridian Names with Meridian Short Names----
Flat_File_eWRIMS <- Flat_File_eWRIMS %>%
mutate(MERIDIAN = case_when(
MERIDIAN == " San Bernardino" ~"S",
MERIDIAN == "Mount Diablo" ~"M",
MERIDIAN == "Humboldt" ~"H",
TRUE ~ MERIDIAN
))
#Add the FFMTRS field----
#This field serves as the Flat File Mountain Township Range Section field
#This field concatenates the Meridian, Township Number, Township Direction, Range Number, Range Direction, and Section Number fields
#This field is used as a basis of comparison with the MTRS field in the PLSS_Sections_Fill shapefile
Flat_File_eWRIMS$FFMTRS = paste0(Flat_File_eWRIMS$MERIDIAN, Flat_File_eWRIMS$TOWNSHIP_NUMBER,
Flat_File_eWRIMS$TOWNSHIP_DIRECTION, Flat_File_eWRIMS$RANGE_NUMBER, Flat_File_eWRIMS$RANGE_DIRECTION,
Flat_File_eWRIMS$SECTION_NUMBER)
#Convert Coordinate Fields From Character Format to Numeric Format----
Flat_File_eWRIMS <- Flat_File_eWRIMS %>%
mutate_at(.vars = vars(LATITUDE, LONGITUDE), .funs = as.numeric)
source("Scripts/Priority_Date_Preprocessing.R")
source("Scripts/Priority_Date.R")
ppYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# For each reporting year, identify a water right's primary owner (by "PARTY_ID")
# This script relies on 'ewrims_flat_file_party.csv' and 'Statistics_FINAL.csv'
#### Dependencies ####
library(tidyverse)
#### Functions ####
mainProcedure <- function () {
# Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
partyDF %>%
group_by(APPLICATION_NUMBER)
partyDF %>%
group_by(APPLICATION_NUMBER)
partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE)))
View(partyDF)
View(mainProcedure)
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
library(tidyverse)
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
View(partyDF)
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID))
View(partyDF)
%>%
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
partyDF %>%
group_by(APPLICATION_NUMBER)
partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE)))
partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1)
partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1)
partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
partydf2 %>% group_by(APPLICATION_NUMBER)
partydf2 >- partydf %>% group_by(APPLICATION_NUMBER)
partyDF2 = partyDF %>% group_by(APPLICATION_NUMBER)
View(partyDF2)
str(partyDF)
head(partyDF)
head(partyDF2)
result <- partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE)))
View(result)
result = partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1)
# For each reporting year, identify a water right's primary owner (by "PARTY_ID")
# This script relies on 'ewrims_flat_file_party.csv' and 'Statistics_FINAL.csv'
#### Dependencies ####
library(tidyverse)
#### Functions ####
mainProcedure <- function () {
# Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# First check for Issue (2)
# At the time of this script's creation (08/03/2023), this issue is not relevant
# (A029789 and D032313 each have duplicates, but "PARTY_ID" is the same in both rows)
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# First check for Issue (2)
# At the time of this script's creation (08/03/2023), this issue is not relevant
# (A029789 and D032313 each have duplicates, but "PARTY_ID" is the same in both rows)
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
table(partyDF$APPLICATION_NUMBER)
freq <- table(partyDF$APPLICATION_NUMBER)
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1]
# Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# First check for Issue (2)
# At the time of this script's creation (08/03/2023), this issue is not relevant
# (A029789 and D032313 each have duplicates, but "PARTY_ID" is the same in both rows)
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
# Next, focus on Issue (1)
# Check for applications with multiple rows in 'partyDF'
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1]
# Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
library(tidyverse)
Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# First check for Issue (2)
# At the time of this script's creation (08/03/2023), this issue is not relevant
# (A029789 and D032313 each have duplicates, but "PARTY_ID" is the same in both rows)
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
# Next, focus on Issue (1)
# Check for applications with multiple rows in 'partyDF'
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1]
table(partyDF$PARTY_ID)
colors <- c("Red", "Green", "Blue", "Red", "Blue", "Green", "Green", "Red")
# Creating the frequency table
freq_table <- table(colors)
print(freq_table)
print(freq)
extraApp <- names(freq)[freq > 1] #501 water rights have more than 1 party ID
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1] #501 water rights have more than 1 party ID
# Separate the rows with and without this issue
singleRowDF <- partyDF %>% filter(!(APPLICATION_NUMBER %in% extraApp))
multiRowDF <- partyDF %>% filter(APPLICATION_NUMBER %in% extraApp)
View(multiRowDF)
View(singleRowDF)
appYears <- appYears %>%
left_join(singleRowDF, by = "APPLICATION_NUMBER", relationship = "many-to-one")
View(appYears)
multiRowDF <- multiRowDF %>%
mutate(START_YEAR = as.numeric(str_extract(EFFECTIVE_FROM_DATE, "[0-9]{4}$")),
END_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$")),
END_YEAR = if_else(!is.na(END_YEAR) & END_YEAR < START_YEAR, START_YEAR, END_YEAR))
multiRowDF <- multiRowDF %>%
mutate(#START_YEAR = if_else(START_YEAR < min(appYears$YEAR), min(appYears$YEAR), START_YEAR),
END_YEAR = if_else(is.na(END_YEAR), max(appYears$YEAR), END_YEAR))
