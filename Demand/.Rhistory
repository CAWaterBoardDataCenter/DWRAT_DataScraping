summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
table(partyDF$APPLICATION_NUMBER)
freq <- table(partyDF$APPLICATION_NUMBER)
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1]
# Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# First check for Issue (2)
# At the time of this script's creation (08/03/2023), this issue is not relevant
# (A029789 and D032313 each have duplicates, but "PARTY_ID" is the same in both rows)
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
# Next, focus on Issue (1)
# Check for applications with multiple rows in 'partyDF'
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1]
# Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
library(tidyverse)
Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# First check for Issue (2)
# At the time of this script's creation (08/03/2023), this issue is not relevant
# (A029789 and D032313 each have duplicates, but "PARTY_ID" is the same in both rows)
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
# Next, focus on Issue (1)
# Check for applications with multiple rows in 'partyDF'
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1]
table(partyDF$PARTY_ID)
colors <- c("Red", "Green", "Blue", "Red", "Blue", "Green", "Green", "Red")
# Creating the frequency table
freq_table <- table(colors)
print(freq_table)
print(freq)
extraApp <- names(freq)[freq > 1] #501 water rights have more than 1 party ID
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1] #501 water rights have more than 1 party ID
# Separate the rows with and without this issue
singleRowDF <- partyDF %>% filter(!(APPLICATION_NUMBER %in% extraApp))
multiRowDF <- partyDF %>% filter(APPLICATION_NUMBER %in% extraApp)
View(multiRowDF)
View(singleRowDF)
appYears <- appYears %>%
left_join(singleRowDF, by = "APPLICATION_NUMBER", relationship = "many-to-one")
View(appYears)
multiRowDF <- multiRowDF %>%
mutate(START_YEAR = as.numeric(str_extract(EFFECTIVE_FROM_DATE, "[0-9]{4}$")),
END_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$")),
END_YEAR = if_else(!is.na(END_YEAR) & END_YEAR < START_YEAR, START_YEAR, END_YEAR))
multiRowDF <- multiRowDF %>%
mutate(#START_YEAR = if_else(START_YEAR < min(appYears$YEAR), min(appYears$YEAR), START_YEAR),
END_YEAR = if_else(is.na(END_YEAR), max(appYears$YEAR), END_YEAR))
# Load required libraries
library(dplyr)
# Sample dataset (replace this with your actual dataset)
data <- data.frame(
APPLICATION_NUMBER = c(1, 2, 3, 4),
PARTY_ID = c("A", "B", "C", "D"),
EFFECTIVE_START_DATE = c("2018-01-01", "2019-01-01", "2020-01-01", "2018-01-01"),
EFFECTIVE_END_DATE = c("2020-12-31", NA, NA, NA),
START_YEAR = c(2018, 2019, 2020, 2018),
END_YEAR = c(2020, NA, NA, NA)
)
# Convert date columns to Date type
data$EFFECTIVE_START_DATE <- as.Date(data$EFFECTIVE_START_DATE)
data$EFFECTIVE_END_DATE <- as.Date(data$EFFECTIVE_END_DATE)
reporting_years <- seq(2018, 2022)
result <- data %>%
filter(START_YEAR %in% reporting_years,
is.na(END_YEAR) | END_YEAR >= (Reporting_Year + 1)) %>%
mutate(Reporting_Year = sapply(EFFECTIVE_START_DATE, function(date) year(date))) %>%
group_by(APPLICATION_NUMBER, Reporting_Year) %>%
summarize(Active_PARTY_ID = first(PARTY_ID))
data <- data.frame(
APPLICATION_NUMBER = c(1, 2, 3, 4),
PARTY_ID = c("A", "B", "C", "D"),
EFFECTIVE_START_DATE = c("2018-01-01", "2019-01-01", "2020-01-01", "2018-01-01"),
EFFECTIVE_END_DATE = c("2020-12-31", NA, NA, NA),
START_YEAR = c(2018, 2019, 2020, 2018),
END_YEAR = c(2020, NA, NA, NA)
)
# Convert date columns to Date type
data$EFFECTIVE_START_DATE <- as.Date(data$EFFECTIVE_START_DATE)
data$EFFECTIVE_END_DATE <- as.Date(data$EFFECTIVE_END_DATE)
# Define the reporting years
reporting_years <- seq(2018, 2022)
# Perform the analysis
result <- data %>%
filter(START_YEAR %in% reporting_years,
is.na(END_YEAR) | END_YEAR >= (Reporting_Year + 1)) %>%
mutate(Reporting_Year = sapply(EFFECTIVE_START_DATE, function(date) year(date))) %>%
group_by(APPLICATION_NUMBER, Reporting_Year) %>%
summarize(Active_PARTY_ID = first(PARTY_ID))
# Load required libraries
library(dplyr)
# Sample dataset (replace this with your actual dataset)
data <- data.frame(
APPLICATION_NUMBER = c(1, 2, 3, 4),
PARTY_ID = c("A", "B", "C", "D"),
EFFECTIVE_START_DATE = c("2018-01-01", "2019-01-01", "2020-01-01", "2018-01-01"),
EFFECTIVE_END_DATE = c("2020-12-31", NA, NA, NA),
START_YEAR = c(2018, 2019, 2020, 2018),
END_YEAR = c(2020, NA, NA, NA)
)
# Convert date columns to Date type
data$EFFECTIVE_START_DATE <- as.Date(data$EFFECTIVE_START_DATE)
data$EFFECTIVE_END_DATE <- as.Date(data$EFFECTIVE_END_DATE)
# Define the reporting years
reporting_years <- seq(2018, 2022)
# Perform the analysis
result <- data %>%
mutate(Reporting_Year = year(EFFECTIVE_START_DATE)) %>%
filter(START_YEAR %in% reporting_years,
is.na(END_YEAR) | END_YEAR >= (Reporting_Year + 1)) %>%
group_by(APPLICATION_NUMBER, Reporting_Year) %>%
summarize(Active_PARTY_ID = first(PARTY_ID))
# Load required libraries
library(dplyr)
# Sample dataset (replace this with your actual dataset)
data <- data.frame(
APPLICATION_NUMBER = c(1, 2, 3, 4),
PARTY_ID = c("A", "B", "C", "D"),
EFFECTIVE_START_DATE = c("2018-01-01", "2019-01-01", "2020-01-01", "2018-01-01"),
EFFECTIVE_END_DATE = c("2020-12-31", NA, NA, NA),
START_YEAR = c(2018, 2019, 2020, 2018),
END_YEAR = c(2020, NA, NA, NA)
)
# Convert date columns to Date type
data$EFFECTIVE_START_DATE <- as.Date(data$EFFECTIVE_START_DATE)
data$EFFECTIVE_END_DATE <- as.Date(data$EFFECTIVE_END_DATE)
# Define the reporting years
reporting_years <- seq(2018, 2022)
result <- data %>%
mutate(Reporting_Year = year(EFFECTIVE_START_DATE)) %>%
filter(START_YEAR %in% reporting_years,
is.na(END_YEAR) | END_YEAR >= (Reporting_Year + 1)) %>%
group_by(APPLICATION_NUMBER, Reporting_Year) %>%
summarize(Active_PARTY_ID = first(PARTY_ID))
library(lubridate)
data <- data.frame(
APPLICATION_NUMBER = c(1, 2, 3, 4),
PARTY_ID = c("A", "B", "C", "D"),
EFFECTIVE_START_DATE = c("2018-01-01", "2019-01-01", "2020-01-01", "2018-01-01"),
EFFECTIVE_END_DATE = c("2020-12-31", NA, NA, NA),
START_YEAR = c(2018, 2019, 2020, 2018),
END_YEAR = c(2020, NA, NA, NA)
)
# Convert date columns to Date type
data$EFFECTIVE_START_DATE <- as.Date(data$EFFECTIVE_START_DATE)
data$EFFECTIVE_END_DATE <- as.Date(data$EFFECTIVE_END_DATE)
# Define the reporting years
reporting_years <- seq(2018, 2022)
# Perform the analysis
result <- data %>%
mutate(Reporting_Year = year(EFFECTIVE_START_DATE)) %>%
filter(START_YEAR %in% reporting_years,
is.na(END_YEAR) | END_YEAR >= (Reporting_Year + 1)) %>%
group_by(APPLICATION_NUMBER, Reporting_Year) %>%
summarize(Active_PARTY_ID = first(PARTY_ID))
# View the result
print(result)
library(readxl)
MultipleOwners <- here("IntermediateData/WATER_RIGHTS_WITH_MULTIPLE_OWNERS.xlsx")
library(here)
data<- here("IntermediateData/WATER_RIGHTS_WITH_MULTIPLE_OWNERS.xlsx")
data<- read_excel(here("IntermediateData/WATER_RIGHTS_WITH_MULTIPLE_OWNERS.xlsx"))
data$EFFECTIVE_START_DATE <- as.Date(data$EFFECTIVE_START_DATE)
# Define the reporting years
reporting_years <- seq(2018, 2023)
result <- data %>%
mutate(Reporting_Year = year(EFFECTIVE_START_DATE)) %>%
filter(START_YEAR %in% reporting_years,
is.na(END_YEAR) | END_YEAR >= (Reporting_Year + 1)) %>%
group_by(APPLICATION_NUMBER, Reporting_Year) %>%
summarize(Active_PARTY_ID = first(PARTY_ID))
data<- read_excel(here("IntermediateData/WATER_RIGHTS_WITH_MULTIPLE_OWNERS.xlsx"))
# Convert date columns to Date type
data$EFFECTIVE_FROM_DATE <- as.Date(data$EFFECTIVE_FROM_DATE)
# Load required libraries
library(dplyr)
data$EFFECTIVE_FROM_DATE <- as.Date(data$EFFECTIVE_FROM_DATE)
result <- data %>%
mutate(Reporting_Year = START_YEAR %>%
filter(START_YEAR %in% reporting_years,
is.na(END_YEAR) | END_YEAR >= (Reporting_Year + 1)) %>%
group_by(APPLICATION_NUMBER, Reporting_Year) %>%
summarize(Active_PARTY_ID = first(PARTY_ID))
# View the result
print(result)
result <- data %>%
mutate(Reporting_Year = START_YEAR) %>%
filter(START_YEAR %in% reporting_years,
is.na(END_YEAR) | END_YEAR >= (Reporting_Year + 1)) %>%
group_by(APPLICATION_NUMBER, Reporting_Year) %>%
summarize(Active_PARTY_ID = first(PARTY_ID))
View(result)
RY_2018 <- data %>%
mutate(Reporting_Year = 2018) %>%
filter(START_YEAR <= Reporting_Year,
is.na(END_YEAR) | END_YEAR >= Reporting_Year)
# View the result
print(result)
RY_2018 <- data %>%
mutate(Reporting_Year = 2018) %>%
filter(START_YEAR <= Reporting_Year,
is.na(END_YEAR) | END_YEAR >= Reporting_Year) %>%
# View the result
print(RY_2018)
RY_2018 <- data %>%
mutate(Reporting_Year = 2018) %>%
filter(START_YEAR <= Reporting_Year,
is.na(END_YEAR) | END_YEAR >= Reporting_Year)
# View the result
print(RY_2018)
RY_2018 <- data %>%
mutate(Reporting_Year = 2018) %>%
filter(START_YEAR <= Reporting_Year,
is.na(END_YEAR) | END_YEAR >= Reporting_Year)
RY_2019 <- data %>%
mutate(Reporting_Year = 2019) %>%
filter(START_YEAR <= Reporting_Year,
is.na(END_YEAR) | END_YEAR >= Reporting_Year)
RY_2020 <- data %>%
mutate(Reporting_Year = 2020) %>%
filter(START_YEAR <= Reporting_Year,
is.na(END_YEAR) | END_YEAR >= Reporting_Year)
RY_2021 <- data %>%
mutate(Reporting_Year = 2021) %>%
filter(START_YEAR <= Reporting_Year,
is.na(END_YEAR) | END_YEAR >= Reporting_Year)
RY_2022 <- data %>%
mutate(Reporting_Year = 2022) %>%
filter(START_YEAR <= Reporting_Year,
is.na(END_YEAR) | END_YEAR >= Reporting_Year)
RY_2023 <- data %>%
mutate(Reporting_Year = 2023) %>%
filter(START_YEAR <= Reporting_Year,
is.na(END_YEAR) | END_YEAR >= Reporting_Year)
library(writexl)
install.packages("writexl")
library(writexl)
RY_Multiple_Owners <- list(Sheet1= RY_2018, Sheet2 = RY_2019, Sheet3 = RY_2020, Sheet4 = RY_2021, Sheet5 = RY_2022, Sheet6 = RY_2023))
RY <- list(
RY_2018 = RY_2018,
RY_2019 = RY_2019,
RY_2020 = RY_2020,
RY_2021 = RY_2021,
RY_2022 = RY_2022,
RY_2023 = RY_2023
)
# Export data frames to an Excel file with separate sheets
write_xlsx(RY, path = here("IntermediateData/ReportingYears_MultipleOwners.xlsx"))
# For each reporting year, identify a water right's primary owner (by "PARTY_ID")
# This script relies on 'ewrims_flat_file_party.csv' and 'Statistics_FINAL.csv'
#### Dependencies ####
library(tidyverse)
#### Functions ####
mainProcedure <- function () {
# Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# First check for Issue (2)
# At the time of this script's creation (08/03/2023), this issue is not relevant
# (A029789 and D032313 each have duplicates, but "PARTY_ID" is the same in both rows)
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
# Next, focus on Issue (1)
# Check for applications with multiple rows in 'partyDF'
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1] #501 water rights have more than 1 party ID
# Separate the rows with and without this issue
singleRowDF <- partyDF %>% filter(!(APPLICATION_NUMBER %in% extraApp))
multiRowDF <- partyDF %>% filter(APPLICATION_NUMBER %in% extraApp)
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# First check for Issue (2)
# At the time of this script's creation (08/03/2023), this issue is not relevant
# (A029789 and D032313 each have duplicates, but "PARTY_ID" is the same in both rows)
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
# Next, focus on Issue (1)
# Check for applications with multiple rows in 'partyDF'
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1] #501 water rights have more than 1 party ID
# Separate the rows with and without this issue
singleRowDF <- partyDF %>% filter(!(APPLICATION_NUMBER %in% extraApp))
multiRowDF <- partyDF %>% filter(APPLICATION_NUMBER %in% extraApp)
# Join the data in 'singleRowDF' to 'appYears'
appYears <- appYears %>%
left_join(singleRowDF, by = "APPLICATION_NUMBER", relationship = "many-to-one")
# Next, focus on 'multiRowDF'
# Get preliminary values for "START_YEAR" and "END_YEAR" using
# "EFFECTIVE_FROM_DATE" and "EFFECTIVE_TO_DATE"
# (Because of the way "END_YEAR" is defined, it does not capture well rightholders
#  that held a right for less than a year; therefore, an extra definition is used)
multiRowDF <- multiRowDF %>%
mutate(START_YEAR = as.numeric(str_extract(EFFECTIVE_FROM_DATE, "[0-9]{4}$")),
END_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$")),
END_YEAR = if_else(!is.na(END_YEAR) & END_YEAR < START_YEAR, START_YEAR, END_YEAR))
# For each application number,
# The final "END_YEAR" will be NA; change that to the maximum year in 'appYears'
multiRowDF <- multiRowDF %>%
mutate(#START_YEAR = if_else(START_YEAR < min(appYears$YEAR), min(appYears$YEAR), START_YEAR),
END_YEAR = if_else(is.na(END_YEAR), max(appYears$YEAR), END_YEAR))
library(tidyverse)
# Read in 'Statistics_FINAL.csv' and create a variable of unique application-year pairs
appYears <- read_csv("IntermediateData/Statistics_FINAL.csv", show_col_types = FALSE) %>%
select(APPLICATION_NUMBER, YEAR, MONTH, AMOUNT, DIVERSION_TYPE) %>% unique()
# Also read in 'ewrims_flat_file_party.csv'
# Filter it down to only "Primary Owner" records and "APPLICATION_ID" values that
# match "APPLICATION_NUMBER" in 'appYears'
# Along with that, the "EFFECTIVE_TO_DATE" should be NA (currently active),
# or the ownership ended during the dataset's timeframe ("EFFECTIVE_TO_DATE" is between 2017-present)
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
# Ideally, there should only be one row per application number in 'partyDF'
# But that will not be the case
# There are two issues that need to be addressed:
# (1) Rights that changed owners over the years
#     "EFFECTIVE_TO_DATE" will be not NA for all except one record
#     The end year in "EFFECTIVE_TO_DATE" **MINUS ONE** will be the last year
#     where that owner is considered the primary owner (because the report
#     for that end year will be filled by the new owner in the subsequent year)
#
# (2) Simultaneously active water rights
#     More than one owner may be listed as an active owner simultaneously
#     Manual review would be needed
# Extract a subset of the columns in 'partyDF'
partyDF <- partyDF %>%
select(APPLICATION_NUMBER, PARTY_ID, EFFECTIVE_FROM_DATE, EFFECTIVE_TO_DATE) %>%
mutate(PARTY_ID = as.numeric(PARTY_ID)) %>%
unique()
# First check for Issue (2)
# At the time of this script's creation (08/03/2023), this issue is not relevant
# (A029789 and D032313 each have duplicates, but "PARTY_ID" is the same in both rows)
if (partyDF %>%
group_by(APPLICATION_NUMBER) %>%
summarize(NA_Count = sum(is.na(EFFECTIVE_TO_DATE))) %>%
filter(NA_Count > 1) %>%
nrow() > 0) {
stop("Manual review is needed (please use 'QAQC_Manual_Review.xlsx'). Though, the code for this procedure has not been implemented yet.")
}
# Next, focus on Issue (1)
# Check for applications with multiple rows in 'partyDF'
freq <- table(partyDF$APPLICATION_NUMBER)
extraApp <- names(freq)[freq > 1] #501 water rights have more than 1 party ID
# Separate the rows with and without this issue
singleRowDF <- partyDF %>% filter(!(APPLICATION_NUMBER %in% extraApp))
multiRowDF <- partyDF %>% filter(APPLICATION_NUMBER %in% extraApp)
# Join the data in 'singleRowDF' to 'appYears'
appYears <- appYears %>%
left_join(singleRowDF, by = "APPLICATION_NUMBER", relationship = "many-to-one")
# Next, focus on 'multiRowDF'
# Get preliminary values for "START_YEAR" and "END_YEAR" using
# "EFFECTIVE_FROM_DATE" and "EFFECTIVE_TO_DATE"
# (Because of the way "END_YEAR" is defined, it does not capture well rightholders
#  that held a right for less than a year; therefore, an extra definition is used)
multiRowDF <- multiRowDF %>%
mutate(START_YEAR = as.numeric(str_extract(EFFECTIVE_FROM_DATE, "[0-9]{4}$")),
END_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$")),
END_YEAR = if_else(!is.na(END_YEAR) & END_YEAR < START_YEAR, START_YEAR, END_YEAR))
partyDF <- read_csv("RawData/ewrims_flat_file_party.csv", col_types = cols(.default = col_character())) %>%
filter(RELATIONSHIP_TYPE == "Primary Owner" & APPLICATION_ID %in% appYears$APPLICATION_NUMBER) %>%
mutate(EFFECTIVE_TO_YEAR = as.numeric(str_extract(EFFECTIVE_TO_DATE, "[0-9]{4}$"))) %>%
filter(is.na(EFFECTIVE_TO_DATE) | EFFECTIVE_TO_YEAR >= min(appYears$YEAR))
View(partyDF)
write.xlsx("IntermediateData/Russian_River_Parties.xlsx")
library(tidyverse)
write.xlsx("IntermediateData/Russian_River_Parties.xlsx")
write_xlsx("IntermediateData/Russian_River_Parties.xlsx")
git add .
write_xlsx("IntermediateData/Russian_River_Parties.xlsx")
library(writexl)
write_xlsx("IntermediateData/Russian_River_Parties.xlsx")
write_xlsx(partyDF, path = "IntermediateData/Russian_River_Parties.xlsx")
